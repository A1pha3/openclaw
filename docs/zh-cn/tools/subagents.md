---
summary: "子代理工具完整指南——并行处理、任务委派与结果汇总"
read_when:
  - 通过代理进行后台或并行工作
  - 配置sessions_spawn或子代理工具策略
  - 理解子代理的生命周期和结果传递
title: "子代理工具"
---

# 子代理工具

本指南全面介绍OpenClaw的子代理（Subagents）系统，帮助您理解如何通过生成隔离的代理运行来实现并行处理、任务委派和后台工作。完成本章节学习后，您将能够有效使用子代理处理复杂任务，理解其生命周期管理，并掌握安全配置和故障排查方法。

## 学习目标

完成本章节学习后，您将能够：

### 基础目标（必掌握）

- 理解子代理的概念和设计目的
- 掌握使用sessions_spawn启动子代理
- 理解子代理的声明周期和结果处理
- 熟悉/subagents斜杠命令的使用

### 进阶目标（建议掌握）

- 配置子代理的模型选择和并发控制
- 理解子代理的认证和权限模型
- 实现多子代理的协调和结果汇总
- 配置子代理的工具策略

### 专家目标（挑战）

- 设计和实现大规模并行任务处理
- 优化子代理的性能和成本
- 实现企业级的任务分发和监控

---

## 第一部分：核心概念解析

### 为什么需要子代理

在深入技术细节之前，我们需要理解子代理的设计目的和价值。

**核心问题**：单个代理在处理复杂任务时面临挑战。

| 问题 | 症状 | 影响 |
|------|------|------|
| **响应延迟** | 长时间任务阻塞主会话 | 用户等待时间长 |
| **资源独占** | 单代理无法并行 | 效率低下 |
| **上下文膨胀** | 长时间任务上下文累积 | 成本增加 |
| **任务耦合** | 多个独立任务必须顺序执行 | 无法优化 |

**子代理的解决方案**：

```
问题：如何让AI助手既能处理复杂任务，又能保持响应性？

解决方案：子代理系统

核心思想：
├── 生成隔离的代理运行处理子任务
├── 主代理继续响应用户
├── 子任务完成后汇总结果
└── 实现真正的并行处理

优势：
├── 更好的响应性——主会话不被阻塞
├── 真正的并行性——多个任务同时处理
├── 资源隔离——子任务独立上下文
├── 成本优化——子任务可使用不同模型
└── 任务分解——复杂任务拆分为可管理单元
```

### 子代理与主代理的关系

```
┌─────────────────────────────────────────────────────────────┐
│                      主代理会话                              │
│  ┌─────────────────────────────────────────────────────┐  │
│  │ 用户请求                                             │  │
│  │  "分析这三个主题并生成报告"                          │  │
│  └───────────────────────┬─────────────────────────────┘  │
│                          │                                  │
│              sessions_spawn                                 │
│                          │                                  │
│          ┌───────────────┼───────────────┐                 │
│          ▼               ▼               ▼                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐         │
│  │ 子代理 1    │ │ 子代理 2    │ │ 子代理 3    │         │
│  │ 分析主题A   │ │ 分析主题B   │ │ 分析主题C   │         │
│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘         │
│         │                │                │                 │
│         └────────────────┼────────────────┘                 │
│                          │                                  │
│                    声明结果                                │
│                          │                                  │
│          ┌───────────────┴───────────────┐                 │
│          ▼                              ▼                 │
│  ┌─────────────────────────────────────────────────────┐  │
│  │ 主代理汇总结果，生成最终报告                          │  │
│  └─────────────────────────────────────────────────────┘  │
│                          │                                  │
│                          ▼                                  │
│                  返回给用户                                 │
└─────────────────────────────────────────────────────────────┘
```

**关键特点**：
- 子代理在独立的会话中运行
- 子代理可以并行执行
- 完成后通过声明机制报告结果
- 主代理负责汇总和响应

### 子代理的隔离设计

```
子代理会话隔离：

┌─────────────────────────────────────────────────────────────┐
│ 主代理会话                                                   │
│ ├── 认证配置文件：A主配置                                    │
│ ├── 工作区：A的工作区                                        │
│ └── 上下文：累积的主会话历史                                  │
├─────────────────────────────────────────────────────────────┤
│ 子代理会话                                                   │
│ ├── 认证：继承A配置 + 自身配置（冲突时子代理优先）           │
│ ├── 工作区：继承或指定                                       │
│ └── 上下文：独立的子代理历史                                  │
├─────────────────────────────────────────────────────────────┤
│ 隔离保证                                                     │
│ ├── 会话分离——独立的sessionKey                             │
│ ├── 上下文隔离——不污染主会话                                │
│ ├── 可选沙箱化——额外的安全隔离                              │
│ └── 工具限制——默认不获取会话工具                            │
└─────────────────────────────────────────────────────────────┘
```

---

## 第二部分：使用方法

### 2.1 启动子代理

使用sessions_spawn工具启动子代理：

**基本调用**：

```json
{
  "tool": "sessions_spawn",
  "task": "请分析这个主题并生成详细报告"
}
```

**带标签的调用**：

```json
{
  "tool": "sessions_spawn",
  "task": "分析市场趋势并提供建议",
  "label": "market-analysis"
}
```

**指定模型的调用**：

```json
{
  "tool": "sessions_spawn",
  "task": "深度代码审查",
  "model": "anthropic/claude-opus-4-5"
}
```

**完整参数调用**：

```json
{
  "tool": "sessions_spawn",
  "task": "复杂分析任务",
  "label": "analysis-1",
  "agentId": "specialist",
  "model": "anthropic/claude-opus-4-5",
  "thinking": "high",
  "runTimeoutSeconds": 600,
  "cleanup": "delete"
}
```

### 2.2 返回值处理

sessions_spawn立即返回（即使子代理未完成）：

```json
{
  "status": "accepted",
  "runId": "subagent-123",
  "childSessionKey": "agent:main:subagent:uuid-123"
}
```

**关键字段**：
- `runId`：用于后续查询和控制的标识
- `childSessionKey`：子代理的完整会话键

### 2.3 子代理会话控制

使用/subagents斜杠命令管理子代理：

```bash
# 列出所有子代理
/subagents list

# 停止子代理
/subagents stop <id>
/subagents stop #1      # 使用编号
/subagents stop all     # 停止所有

# 查看日志
/subagents log <id>
/subagents log <id> 50  # 限制行数
/subagents log <id> 100 tools  # 包含工具调用

# 查看信息
/subagents info <id>

# 发送消息
/subagents send <id> <message>
```

---

## 第三部分：生命周期详解

### 3.1 生命周期阶段

```
子代理生命周期：

┌─────────────────────────────────────────────────────────────┐
│ 1. 启动阶段                                                   │
│ ├── 验证参数                                                  │
│ ├── 分配会话键                                                │
│ ├── 初始化上下文                                              │
│ └── 返回accepted状态                                         │
├─────────────────────────────────────────────────────────────┤
│ 2. 执行阶段                                                   │
│ ├── 加载认证配置                                             │
│ ├── 注入AGENTS.md + TOOLS.md                                 │
│ ├── 执行任务                                                  │
│ └── 主代理可继续响应                                          │
├─────────────────────────────────────────────────────────────┤
│ 3. 声明阶段                                                   │
│ ├── 子代理完成任务                                            │
│ ├── 执行声明步骤（可选）                                      │
│ ├── 发布结果到主会话                                         │
│ └── 发布统计信息                                             │
├─────────────────────────────────────────────────────────────┤
│ 4. 清理阶段                                                   │
│ ├── 自动归档（默认60分钟后）                                 │
│ ├── 或立即删除（cleanup: "delete"）                          │
│ └── 保留记录（重命名为*.deleted.<timestamp>）                │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 声明机制

子代理通过声明步骤报告结果：

**声明模板**：

```
┌─────────────────────────────────────────────────────────────┐
│ Status: <success|error|timeout|unknown>                      │
├─────────────────────────────────────────────────────────────┤
│ Result: <声明步骤的摘要内容>                                 │
├─────────────────────────────────────────────────────────────┤
│ Notes: <错误详情和其他有用上下文>                             │
├─────────────────────────────────────────────────────────────┤
│ Runtime: <运行时长>                                         │
│ Input Tokens: <输入token数>                                 │
│ Output Tokens: <输出token数>                                 │
│ Total Tokens: <总token数>                                   │
│ Session Key: <会话键>                                        │
│ Session ID: <会话ID>                                         │
└─────────────────────────────────────────────────────────────┘
```

**声明选项**：
- 正常声明：发布结果到主会话
- ANNOUNCE_SKIP：跳过声明，不发布任何内容
- 错误处理：声明包含错误详情

### 3.3 自动归档

```json5
{
  agents: {
    defaults: {
      subagents: {
        archiveAfterMinutes: 60  // 默认60分钟后归档
      }
    }
  }
}
```

**归档行为**：
- 使用sessions.delete删除会话
- 重命名记录文件为*.deleted.<timestamp>
- 保留记录以便审计

**注意事项**：
- 自动归档是尽力而为的
- 网关重启后待处理计时器丢失
- cleanup: "delete"立即归档但仍保留记录

---

## 第四部分：高级配置

### 4.1 模型配置

**默认模型**：继承调用者的模型

```json5
{
  agents: {
    defaults: {
      subagents: {
        model: "anthropic/claude-haiku-4"  // 覆盖默认
      }
    }
  }
}
```

**每代理配置**：

```json5
{
  agents: {
    list: [
      {
        id: "main",
        subagents: {
          model: "anthropic/claude-haiku-4"
        }
      }
    ]
  }
}
```

**优先级**：
1. sessions_spawn.model（显式指定）
2. agents.list[].subagents.model（每代理）
3. agents.defaults.subagents.model（全代理）
4. 继承调用者模型（最终回退）

### 4.2 并发控制

```json5
{
  agents: {
    defaults: {
      subagents: {
        maxConcurrent: 8  // 默认8个并发
      }
    }
  }
}
```

**并发队列**：
- 专用进程内队列
- 车道名称：subagent
- 超出并发限制时排队等待

### 4.3 认证配置

**认证继承规则**：

```
子代理认证 = 子代理的认证 + 主代理认证作为回退

优先级：
1. 子代理的agentDir中的认证文件
2. 主代理的认证文件（回退）
3. 冲突时：子代理配置优先
```

**说明**：
- 合并是累加的
- 主配置文件始终可用作回退
- 完全隔离认证尚不支持

### 4.4 工具策略

**默认策略**：子代理获取除会话工具外的所有工具

**会话工具（默认排除）**：
- sessions_list
- sessions_history
- sessions_send
- sessions_spawn

**自定义工具策略**：

```json5
{
  tools: {
    subagents: {
      tools: {
        deny: ["gateway", "cron"],  // deny始终生效
        // allow: ["read", "exec"]  // 如果设置，仅允许这些
      }
    }
  }
}
```

### 4.5 代理目标限制

控制子代理可以定位的代理ID：

```json5
{
  agents: {
    list: [
      {
        id: "main",
        subagents: {
          allowAgents: ["specialist"]  // 仅能生成到specialist
        }
      }
    ]
  }
}
```

**选项**：
- ["specific-agent"]：仅特定代理
- ["*"]：允许任何代理
- 默认：仅请求者代理

---

## 第五部分：使用场景

### 5.1 并行研究

**需求**：同时研究多个主题

**实现**：

```json
{
  "tool": "sessions_spawn",
  "task": "研究AI在医疗领域的应用",
  "label": "medical-ai"
}
{
  "tool": "sessions_spawn",
  "task": "研究AI在金融领域的应用",
  "label": "finance-ai"
}
{
  "tool": "sessions_spawn",
  "task": "研究AI在制造领域的应用",
  "label": "manufacturing-ai"
}
```

**结果汇总**：

```
等待所有子代理完成后：

┌─────────────────────────────────────────────────────────────┐
│ 综合报告                                                    │
│                                                             │
│ 1. 医疗领域                                                 │
│    - 影像诊断                                               │
│    - 药物发现                                               │
│                                                             │
│ 2. 金融领域                                                 │
│    - 风险评估                                               │
│    - 欺诈检测                                               │
│                                                             │
│ 3. 制造领域                                                 │
│    - 预测维护                                               │
│    - 质量控制                                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 长时间任务

**需求**：执行需要长时间的分析任务

**实现**：

```json
{
  "tool": "sessions_spawn",
  "task": "深度分析这个代码库，识别架构模式和潜在问题",
  "runTimeoutSeconds": 1800  // 30分钟超时
}
```

**监控**：

```bash
# 查看状态
/subagents list
/subagents info <id>

# 查看日志
/subagents log <id> 100 tools

# 发送消息
/subagents send <id> 进度如何？

# 需要时停止
/subagents stop <id>
```

### 5.3 任务委派

**需求**：将专业任务委派给专用代理

**配置**：

```json5
{
  agents: {
    list: [
      {
        id: "main",
        subagents: {
          allowAgents: ["coding", "writing", "analysis"]
        }
      },
      {
        id: "coding",
        model: "anthropic/claude-opus-4-5",
        thinkingDefault: "high"
      },
      {
        id: "writing",
        thinkingDefault: "medium"
      }
    ]
  }
}
```

**执行**：

```json
{
  "tool": "sessions_spawn",
  "task": "审查这段代码的潜在安全问题",
  "agentId": "coding"
}
```

### 5.4 结果收集与汇总

**模式**：

```
1. 生成多个子代理
2. 收集各子代理的结果
3. 主代理分析并汇总
4. 生成综合报告
```

**示例**：

```json
{
  "tool": "sessions_spawn",
  "task": "分析用户反馈，按类别分类并统计",
  "label": "feedback-analysis"
}
```

**后续处理**：

```
收集反馈
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 子代理返回：                                                  │
│                                                             │
│ Category | Count | Examples                                │
│ ─────────┼────────┼─────────────────────────────────────  │
│ Bug      │ 45     │ "登录失败"                             │
│ Feature  │ 32     │ "需要主题切换"                        │
│ Question │ 28     │ "如何导出数据"                         │
│ Other    │ 15     │ ...                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
主代理生成报告
```

---

## 第六部分：安全与限制

### 6.1 声明的尽力而为特性

**限制**：
- 网关重启后待处理的"宣布回"工作丢失
- 子代理共享网关进程资源
- maxConcurrent作为安全阀

**缓解措施**：
- 实现任务状态持久化
- 使用外部消息队列（高级）
- 合理配置maxConcurrent

### 6.2 成本控制

**注意事项**：
- 每个子代理有独立的上下文和token使用
- 长时间运行的子代理累积上下文成本
- 并发子代理增加总体成本

**优化建议**：

| 场景 | 建议 |
|------|------|
| 成本敏感 | 为子代理配置更便宜的模型 |
| 质量敏感 | 保持主代理使用高质量模型 |
| 大规模并行 | 限制maxConcurrent |

### 6.3 上下文限制

**注入内容**：
- AGENTS.md
- TOOLS.md

**不注入内容**：
- SOUL.md
- IDENTITY.md
- USER.md
- HEARTBEAT.md
- BOOTSTRAP.md

**原因**：保持子代理轻量和专注

### 6.4 会话管理

**停止主会话影响**：

```
/stop 命令
    │
    ▼
中止当前主会话
    │
    ▼
停止从该主会话生成的所有活动子代理
```

---

## 第七部分：故障排除

### 7.1 常见问题

| 问题 | 症状 | 解决方案 |
|------|------|----------|
| 子代理无响应 | 任务启动但不执行 | 检查子代理会话状态 |
| 结果未发布 | 等待但无结果 | 检查ANNOUNCE_SKIP |
| 认证失败 | 无法访问资源 | 检查认证继承 |
| 资源耗尽 | 系统变慢 | 减少并发数量 |

### 7.2 子代理未执行

**症状**：sessions_spawn返回accepted但无后续

**排查步骤**：

```bash
# 1. 检查子代理列表
/subagents list

# 2. 查看详细信息
/subagents info <id>

# 3. 检查日志
/subagents log <id>

# 4. 检查会话历史
/subagents log <id> 50 tools
```

### 7.3 结果未声明

**症状**：子代理完成但主会话无结果

**排查步骤**：

```bash
# 1. 检查子代理状态
/subagents info <id>

# 2. 查看最后日志
/subagents log <id> 20

# 3. 检查是否ANNOUNCE_SKIP
# 查看子代理的最终响应

# 4. 检查网络连接
# 声明需要网络访问主会话
```

### 7.4 认证问题

**症状**：子代理无法访问资源

**解决方案**：

```bash
# 1. 检查认证配置
openclaw config get agents.list

# 2. 检查认证文件
ls ~/.openclaw/agents/<agent-id>/

# 3. 测试手动访问
# 确认认证可以单独工作
```

### 7.5 性能问题

**症状**：子代理响应慢或系统变慢

**优化建议**：

| 问题 | 解决方案 |
|------|----------|
| 内存使用高 | 减少并发或使用更小模型 |
| 上下文累积快 | 减少任务复杂度或缩短超时 |
| 响应慢 | 检查网络或增加超时 |

---

## 第八部分：专家思维模型

### 8.1 任务分解决策

```
何时使用子代理？

问题：这个任务应该用子代理吗？
    │
    ▼
任务可以并行吗？
    │
    ├─是→ 多个独立子任务 → 使用子代理
    │
    └─否→ 任务需要顺序依赖
              │
              ▼
          任务耗时超过30秒吗？
              │
              ├─是→ 使用子代理避免阻塞
              │
              └─否→ 可直接在主会话处理
                        │
                        ▼
                    任务复杂到需要专门模型吗？
                        │
                        ├─是→ 子代理可指定不同模型
                        │
                        └─否→ 主会话处理即可
```

### 8.2 并发设计

```
最佳并发策略：

因素：
├── 系统资源（CPU、内存）
├── API速率限制
├── 成本预算
└── 任务依赖

推荐配置：
├── 轻量任务：maxConcurrent: 16
├── 中等任务：maxConcurrent: 8
├── 重型任务：maxConcurrent: 4
└── 超重型：maxConcurrent: 2
```

### 8.3 成本优化策略

```
子代理成本模型：

成本 = Σ(子代理token使用 × 模型单价)

优化策略：
├── 简单子任务 → 使用小模型（haiku）
├── 复杂子任务 → 使用大模型（opus）
├── 批量子任务 → 并发处理减少等待
└── 长生命周期 → 设置合理超时
```

### 8.4 可靠性设计

```
提高子代理可靠性：

1. 超时设置
   └── 为每个子代理设置合理超时

2. 错误处理
   └── 设计子代理能优雅处理错误

3. 结果验证
   └── 检查子代理结果的有效性

4. 后备策略
   └── 准备子代理失败时的备选方案
```

---

## 适用场景速查

| 场景 | 使用方式 | 配置建议 |
|------|----------|----------|
| 并行研究 | 多个子代理 | 高并发、标签管理 |
| 长时间任务 | 单子代理 | 合理超时、后台监控 |
| 任务委派 | 指定agentId | 配置allowAgents |
| 结果收集 | 声明机制 | 设计汇总逻辑 |
| 成本优化 | 不同模型 | 分层模型配置 |

---

## 相关文档

- [会话管理](/concepts/session)——会话上下文
- [工具策略](/concepts/tools)——工具配置
- [认证配置](/concepts/auth)——认证管理
- [Agent工具发送](/cli#agent-send)——agent调用

---

**最佳实践**：子代理是处理复杂并行任务的有效工具。在使用时，合理分解任务、配置并发限制、优化模型选择，并设计可靠的结果处理机制。对于关键任务，始终准备后备方案和错误处理。