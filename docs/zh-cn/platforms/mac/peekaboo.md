---
summary: "用于 macOS UI 自动化的 PeekabooBridge 集成"
read_when:
  - 在 OpenClaw.app 中托管 PeekabooBridge
  - 通过 Swift Package Manager 集成 Peekaboo
  - 更改 PeekabooBridge 协议/路径
title: "Peekaboo Bridge"
---

# Peekaboo Bridge（macOS UI 自动化）

OpenClaw 可以托管 **PeekabooBridge** 作为本地的、权限感知的 UI 自动化代理。这让 `peekaboo` CLI 在复用 macOS 应用的 TCC 权限的同时驱动 UI 自动化。

## 这是什么（和不是什么）

- **主机**：OpenClaw.app 可以作为 PeekabooBridge 主机。
- **客户端**：使用 `peekaboo` CLI（没有单独的 `openclaw ui ...` 接口）。
- **UI**：可视化覆盖层保留在 Peekaboo.app 中；OpenClaw 是一个精简的代理主机。

## 启用桥接

在 macOS 应用中：

- 设置 → **Enable Peekaboo Bridge**

启用后，OpenClaw 启动一个本地 UNIX socket 服务器。如果禁用，主机会停止，`peekaboo` 将回退到其他可用的主机。

## 客户端发现顺序

Peekaboo 客户端通常按此顺序尝试主机：

1. Peekaboo.app（完整 UX）
2. Claude.app（如果已安装）
3. OpenClaw.app（精简代理）

使用 `peekaboo bridge status --verbose` 查看哪个主机活跃以及使用的 socket 路径。你可以通过以下方式覆盖：

```bash
export PEEKABOO_BRIDGE_SOCKET=/path/to/bridge.sock
```

## 安全与权限

- 桥接验证**调用者代码签名**；强制执行 TeamID 允许列表（Peekaboo 主机 TeamID + OpenClaw 应用 TeamID）。
- 请求在约 10 秒后超时。
- 如果缺少所需权限，桥接返回清晰的错误消息，而不是启动系统设置。

## 快照行为（自动化）

快照存储在内存中，在短窗口后自动过期。如果你需要更长的保留时间，从客户端重新捕获。

## 故障排除

- 如果 `peekaboo` 报告"bridge client is not authorized"，确保客户端正确签名，或者在**调试**模式下仅使用 `PEEKABOO_ALLOW_UNSIGNED_SOCKET_CLIENTS=1` 运行主机。
- 如果找不到主机，打开其中一个主机应用（Peekaboo.app 或 OpenClaw.app）并确认已授予权限。
