---
summary: "音频与语音消息处理 - 下载、转录和注入回复"
read_when:
  - 修改音频转录或媒体处理
  - 配置语音识别服务
  - 了解音频处理流程
title: "音频与语音消息"
---

# 🎤 音频与语音消息处理

## 学习目标

完成本章节学习后，你将能够：

### 基础目标（必掌握）

- [ ] 理解 **音频处理管道** 的工作原理
- [ ] 掌握音频文件下载和转录的流程
- [ ] 理解自动检测机制的原理和配置方法
- [ ] 完成基础的音频转录配置

### 进阶目标（建议掌握）

- [ ] 配置多种转录服务（本地 CLI、云服务）
- [ ] 优化转录质量和性能
- [ ] 处理特殊音频格式和编码

### 专家目标（挑战）

- [ ] 自定义转录模型和参数
- [ ] 集成私有转录服务
- [ ] 大规模音频处理优化

---

## 为什么需要音频处理？

在理解具体用法之前，我们需要先理解**设计者为什么引入音频处理功能**。这不仅帮助你更好地使用转录功能，还能让你在优化音频处理流程时做出更好的设计决策。

### 设计决策背景

**问题**：入站音频消息无法被 AI 模型直接处理，需要转换为文字

**可选方案**：

1. 方案 A - 仅提供原始音频：AI 模型无法理解音频内容
2. 方案 B - 强制使用云服务：依赖网络，隐私风险
3. 方案 C（最终选择）- 多模式转录：本地 CLI + 云服务双模式

**选择理由**：

- 理由一：本地 CLI 保护隐私，无需上传音频
- 理由二：云服务作为回退，保证可用性
- 理由三：智能大小限制避免处理超大文件

### 音频处理管道架构图

```
┌─────────────────────────────────────────────────────────────┐
│                   音频处理管道架构                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  入站音频消息                                                 │
│      │                                                       │
│      ▼                                                       │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  1. 定位附件                                           │    │
│  │     - 本地路径 → 直接使用                               │    │
│  │     - URL → 下载到临时文件                              │    │
│  └─────────────────────────────┬───────────────────────────┘    │
│                                │                               │
│                                ▼                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  2. 大小检查                                          │    │
│  │     - 检查文件大小是否超过 maxBytes                    │    │
│  │     - 超过则跳过该模型，尝试下一个                    │    │
│  └─────────────────────────────┬───────────────────────────┘    │
│                                │                               │
│                                ▼                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  3. 模型调用                                          │    │
│  │     - 按配置顺序尝试每个模型                          │    │
│  │     - 检查认证信息                                    │    │
│  │     - 发送音频到转录服务                              │    │
│  └─────────────────────────────┬───────────────────────────┘    │
│                                │                               │
│                ┌───────────────┴───────────────┐               │
│                │                               │               │
│                ▼                               ▼               │
│        ┌───────────────┐               ┌───────────────┐      │
│        │   转录成功     │               │   转录失败     │      │
│        │               │               │               │      │
│        ▼               │               ▼               │      │
│  ┌───────────┐         │       ┌───────────┐         │      │
│  │ 替换 Body │         │       │ 尝试下一个│         │      │
│  │ 设置变量  │         │       │   模型    │         │      │
│  └───────────┘         │       └───────────┘         │      │
│                         │                           │      │
│                         └───────────────────────────┘      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 核心概念速查

| 概念 | 定义 | 关键特性 |
|------|------|---------|
| **音频处理管道** | 入站音频到文字的完整流程 | 下载、转录、注入、回复 |
| **自动检测** | 未配置模型时的智能选择机制 | CLI 优先、云服务回退 |
| **转录模型** | 执行音频转录的服务配置 | 本地 CLI、云服务 API |
| **大小限制** | 防止处理超大文件的机制 | maxBytes、maxChars |

---

## 适用场景分析

### 场景一：语音消息转文字

**需求**：将收到的语音消息转换为文字，便于 AI 处理

**解决方案**：

```
语音消息 → 下载音频 → 转录为文字 → AI 理解 → 生成回复
```

**实际案例**：

- 微信/WhatsApp 语音消息处理
- 电话录音转文字
- 会议录音摘要

### 场景二：多语言语音处理

**需求**：处理多种语言的语音输入

**解决方案**：

```
语音输入 → 语言检测 → 相应语言模型 → 转录 → AI 处理
```

**实际案例**：

- 多语言会议记录
- 跨语言沟通辅助
- 外语学习材料处理

### 场景三：离线转录需求

**需求**：在无网络环境下处理音频

**解决方案**：

```
本地 CLI 转录 → 无需网络 → 转录结果 → AI 处理
```

**实际案例**：

- 隐私敏感场景
- 网络不稳定地区
- 实时转录需求

---

## 专家思维模型：音频处理优化框架

当优化音频处理流程时，专家会采用以下思维框架：

### 优化维度分析

```
音频处理性能
    │
    ├─→ 速度
    │   ├─→ 本地 CLI vs 云服务
    │   ├─→ 并发处理能力
    │   └─→ 缓存机制
    │
    ├─→ 准确率
    │   ├─→ 模型选择
    │   ├──→ 音频预处理
    │   └─→ 后处理校正
    │
    ├─→ 成本
    │   ├─→ API 调用费用
    │   ├─→ 本地资源消耗
    │   └─→ 存储成本
    │
    └─→ 兼容性
        ├─→ 音频格式支持
        ├─→ 编码兼容性
        └─→ 平台差异
```

### 故障转移决策树

```
音频转录失败？
    │
    ├─→ 模型错误？
    │   ├─→ 是 → 检查认证信息
    │   │
    │   └─→ 否 → 检查文件大小
    │               │
    │               ├─→ 超过限制 → 尝试 CLI 回退
    │               │
    │               └─→ 未超限 → 检查网络连接
    │                           │
    │                           ├─→ 网络问题 → 使用本地 CLI
    │                           │
    │                           └─→ 网络正常 → 联系服务提供商
```

---

## 学习路径规划

### 阶段一：基础概念（1-2 小时）

**目标**：建立音频处理的认知框架

1. 阅读本教程，理解处理管道
2. 测试默认的自动检测
3. 完成第一次音频转录

### 阶段二：核心功能（2-4 小时）

**目标**：掌握实际使用中最常用的功能

4. 配置本地 CLI 转录
5. 配置云服务 API
6. 优化大小限制和超时

### 阶段三：高级应用（4-8 小时）

**目标**：解决复杂场景和高级需求

7. 配置多个转录服务
8. 实现故障自动转移
9. 自定义转录提示词

### 阶段四：专家实战（8+ 小时）

**目标**：解决真实世界的复杂问题

10. 大规模音频处理
11. 私有化部署
12. 自定义模型训练

---

## 渐进式复杂度：转录方式对比

### 转录方式功能矩阵

| 方式 | 速度 | 准确率 | 成本 | 隐私 | 离线支持 |
|-----|-----|-------|-----|-----|---------|
| **sherpa-onnx-offline** | 快 | 高 | 免费 | 完美 | ✅ |
| **whisper-cli** | 快 | 高 | 免费 | 完美 | ✅ |
| **whisper** | 中 | 高 | 免费 | 完美 | ✅ |
| **OpenAI Whisper API** | 快 | 很高 | 按量付费 | 需上传 | ❌ |
| **Deepgram** | 很快 | 很高 | 按量付费 | 需上传 | ❌ |
| **Google Speech** | 快 | 高 | 按量付费 | 需上传 | ❌ |

### 复杂度等级说明

| 等级 | 描述 | 示例任务 |
|-----|------|---------|
| **Level 1 ⭐** | 使用默认自动检测 | 配置 API Key，测试转录 |
| **Level 2 ⭐⭐** | 配置本地 CLI 转录 | 安装 sherpa-onnx，设置模型路径 |
| **Level 3 ⭐⭐⭐** | 混合使用多种服务 | 配置主备切换，优化成本 |
| **Level 4 ⭐⭐⭐⭐** | 自定义部署 | 私有模型部署，大规模优化 |

---

## 故障排查实战

### 场景一：转录失败

**问题描述**：音频文件无法转录，返回错误

**排查步骤**：

1. **检查音频文件**

   ```bash
   # 检查文件是否存在
   ls -la audio.mp3
   
   # 检查文件格式
   file audio.mp3
   
   # 检查文件大小
   du -h audio.mp3
   ```

2. **检查 CLI 是否安装**

   ```bash
   # 检查 whisper 是否可用
   which whisper
   whisper --version
   
   # 检查 sherpa-onnx 是否可用
   which sherpa-onnx-offline
   ```

3. **查看详细日志**

   ```bash
   openclaw logs --verbose | grep audio
   ```

4. **手动测试转录服务**

   ```bash
   # 测试 OpenAI API
   curl -X POST "https://api.openai.com/v1/audio/transcriptions" \
     -H "Authorization: Bearer $OPENAI_API_KEY" \
     -F "file=@audio.mp3" \
     -F "model=whisper-1"
   ```

**解决方案**：

- 确保音频文件有效
- 安装必要的 CLI 工具
- 修复 API 认证配置

### 场景二：权限问题

**问题描述**：API 调用返回认证错误

**排查步骤**：

1. **检查 API Key**

   ```bash
   # 查看环境变量
   echo $OPENAI_API_KEY
   echo $DEEPGRAM_API_KEY
   
   # 验证 Key 格式
   ```

2. **检查配置文件**

   ```bash
   openclaw config get tools.media.audio.models
   ```

3. **测试 API 连接**

   ```bash
   # OpenAI 连接测试
   curl -s https://api.openai.com/v1/models \
     -H "Authorization: Bearer $OPENAI_API_KEY"
   ```

**解决方案**：

- 设置正确的 API Key
- 检查配置文件路径
- 验证 API Key 权限

### 场景三：大文件处理失败

**问题描述**：超过大小限制的音频无法处理

**排查步骤**：

1. **检查当前限制**

   ```bash
   openclaw config get tools.media.audio.maxBytes
   ```

2. **调整大小限制**

   ```bash
   # 设置更大的限制（如 50MB）
   openclaw config set tools.media.audio.maxBytes 52428800
   ```

3. **分段处理超大文件**

   ```bash
   # 使用音频编辑工具分割
   ffmpeg -i input.mp3 -ss 00:00:00 -to 00:05:00 -c copy part1.mp3
   ```

**解决方案**：

- 按需调整大小限制
- 使用本地 CLI 处理超大文件
- 预先分割音频文件

---

## 最佳实践

### 实践一：本地 CLI 转录配置

**目标**：保护隐私，减少成本

```json5
{
  tools: {
    media: {
      audio: {
        enabled: true,
        models: [
          {
            type: "cli",
            command: "sherpa-onnx-offline",
            args: [
              "--tokens", "${SHERPA_ONNX_MODEL_DIR}/tokens.txt",
              "--encoder", "${SHERPA_ONNX_MODEL_DIR}/encoder.onnx",
              "--decoder", "${SHERPA_ONNX_MODEL_DIR}/decoder.onnx",
              "--joiner", "${SHERPA_ONNX_MODEL_DIR}/joiner.onnx",
              "{{MediaPath}}"
            ],
            timeoutSeconds: 60
          }
        ]
      }
    }
  }
}
```

**最佳实践要点**：

- 设置 SHERPA_ONNX_MODEL_DIR 环境变量
- 选择适合的模型大小
- 配置合理的超时时间

### 实践二：混合转录服务配置

**目标**：平衡速度、成本和可用性

```json5
{
  tools: {
    media: {
      audio: {
        enabled: true,
        maxBytes: 20971520,  // 20MB
        models: [
          {
            type: "provider",
            provider: "openai",
            model: "gpt-4o-mini-transcribe"
          },
          {
            type: "cli",
            command: "whisper",
            args: ["--model", "base", "{{MediaPath}}"],
            timeoutSeconds: 45
          }
        ]
      }
    }
  }
}
```

**最佳实践要点**：

- 主服务优先使用云服务（速度优先）
- 备用服务使用本地 CLI（成本/隐私优先）
- 设置合理的超时和大小限制

### 实践三：范围限制配置

**目标**：精细控制音频处理范围

```json5
{
  tools: {
    media: {
      audio: {
        enabled: true,
        scope: {
          default: "allow",
          rules: [
            { action: "deny", match: { chatType: "group" } },
            { action: "allow", match: { channel: "telegram" } }
          ]
        },
        models: [
          { provider: "openai", model: "gpt-4o-mini-transcribe" }
        ]
      }
    }
  }
}
```

**最佳实践要点**：

- 群组禁用以节省成本
- 特定渠道启用以满足需求
- 结合业务场景灵活配置

---

## CLI 命令参考

### 音频处理命令

| 命令 | 说明 |
|------|------|
| `openclaw message send --media <audio>` | 发送音频消息 |
| `openclaw config get tools.media.audio` | 查看音频配置 |
| `openclaw config set tools.media.audio.enabled false` | 禁用音频处理 |

### 转录测试命令

```bash
# 测试本地 CLI 转录
whisper audio.mp3 --model base

# 测试 API 转录
curl -X POST "https://api.openai.com/v1/audio/transcriptions" \
  -H "Authorization: Bearer $OPENAI_API_KEY" \
  -F "file=@audio.mp3" \
  -F "model=whisper-1"
```

---

## 原理解析：自动检测机制

### 检测优先级

当未配置转录模型时，OpenClaw 按以下顺序自动检测可用的转录方式：

```
1. 检查 sherpa-onnx-offline
   │
   ├── 可用 → 使用本地离线转录
   │
   └── 不可用 → 2. 检查 whisper-cli
                  │
                  ├── 可用 → 使用 whisper CLI
                  │
                  └── 不可用 → 3. 检查 whisper
                                 │
                                 ├── 可用 → 使用 whisper Python CLI
                                 │
                                 └── 不可用 → 4. 检查 Gemini CLI
                                                │
                                                ├── 可用 → 使用 Gemini
                                                │
                                                └── 不可用 → 5. 检查云服务 API
                                                               │
                                                               ├── OpenAI API → 使用 Whisper
                                                               │
                                                               ├── Groq API → 使用 Whisper
                                                               │
                                                               ├── Deepgram API → 使用 Nova
                                                               │
                                                               └── Google API → 使用 Speech-to-Text
```

### 认证优先级

当使用云服务时，认证信息按以下优先级查找：

```
1. Auth 配置文件
   │
   ├── 存在且有效 → 使用配置文件认证
   │
   └── 不存在或无效 → 2. 环境变量
                        │
                        ├── 存在 → 使用环境变量
                        │
                        └── 不存在 → 3. 配置文件中的 apiKey
                                         │
                                         ├── 存在 → 使用 apiKey
                                         │
                                         └── 不存在 → 返回错误
```

---

## 总结

音频处理是 OpenClaw 处理多媒体消息的关键功能。通过完善的转录管道，你可以：

- 将语音消息转换为文字
- 实现多语言语音处理
- 保护隐私的本地转录
- 灵活的服务配置和故障转移

掌握音频处理的配置和优化，将极大地扩展 AI 助手处理多媒体消息的能力。

---

## 进阶学习路径

| 级别 | 主题 | 资源 |
|-----|------|-----|
| ⭐ | 基础转录配置 | [快速开始](/zh-CN/start/quick-start) |
| ⭐⭐ | 本地 CLI 配置 | [sherpa-onnx 文档](https://github.com/k2-fsa/sherpa-onnx) |
| ⭐⭐⭐ | 云服务集成 | [OpenAI 文档](https://platform.openai.com/docs/api-reference/audio) |
| ⭐⭐⭐⭐ | 大规模部署 | [开发者文档](/zh-CN/developers) |

---

## 相关文档

- [媒体理解](/zh-CN/nodes/media-understanding) - 媒体处理概述
- [相机节点](/zh-CN/nodes/camera) - 图像捕获
- [配置参考](/zh-CN/config/reference) - 完整配置选项
- [CLI 参考](/zh-CN/cli) - 命令行工具

---

**音频处理让语音消息也能被 AI 理解和回应！** 🦞